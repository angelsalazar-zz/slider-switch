<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="highlight-behavior.html">

<dom-module id="slider-switch">
   <template>
     <style>
         :host {
             display: block;
         }
         /* Hover when it's not selected, check for hover property */
         :host[hover] > .switch{
           stroke: #1565C0;
           fill: #1565C0;
         }
         /* when selected, check for is-selected property  */
         :host[is-selected] > .switch{
           stroke: #FF9800;
           fill: #FF9800;
         }
         /* Hover when it's selected, check for hover and is-selected property */
         :host[is-selected][hover] > .switch{
           stroke: #B71C1C;
           fill: #B71C1C;
         }
         /* svg style */
         .switch{
             position: absolute;
             margin-left: -5px;
             height: 100%;
             width: 10px;
             stroke: #90CAF9;
             stroke-width: 2;
             fill: #90CAF9;
         }
         /* popup value style */
         .value {
           position: absolute;
           background-color: #7CADAD;
           color: #EEEEEE;
           padding: 3px;
           width: auto;
           height: auto;
           margin-left: -12px;
           font: 11px arial, sans-serif;
           border: .5px solid;
           border-radius: 10px;
         }
    </style>
    <div class="value"
        style$="left:{{position}}px; display:{{visibility}}; top:{{topPos}}px">
        {{value}}</div>
    <svg class="switch"
         style$="left:{{position}}px">
        <polygon points$="{{points}}" />
    </svg>
  </template>
   <script>
       Polymer({
           //custom element name
           is: 'slider-switch',
           //custom behavior (select and hover behavior)
           behaviors: [HighlightBehavior],
           /*
           listeners
           down (mousedown)
           _handleDown callback
           */
           listeners: {
               down: '_handleDown'
           },
           /*
            Properties
            position:Number - Current slider-switch position (pixeles),
            isDragging:Boolean - Active when dragging the slider-switch (shows popup value on dragging),
            isSelected:Boolean - ,
            _startX:Number - Private prop, helper used to store where the drag event start
            _topPos: Number - style variable for popup value
            isSelectable:Boolean - Allow slider-switch to be selectable component or not
            value:Number - Current slider-value
           */
           properties:{
               position: {
                   type: Number,
                   value: 0,
                   notify: true
               },
               isDragging: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true,
                    observer: "_displayText"
                },
               isSelected: {
                   type: Boolean,
                   value: false,
                   reflectToAttribute: true
               },
               _startX:{
                   type: Number,
                   value: 0
               },
               uid:{
                   type:String,
                   reflectToAttribute: true
               },
               topPos:{
                 type: Number,
                 reflectToAttribute: true
               },
               isSelectable:{
                 type: Boolean,
                 value:false,
                 reflectToAttribute:true
               },
               value: {
                  type:Number,
                  notify:true,
                  reflectToAttribute:true
                },
           },
           /**
           * attached callback, set the position based on a value
           *
           */
           attached:function(){
              var _zone = Polymer.dom(this).parentNode;
              this.position = Math.round((this.value*_zone.getBoundingClientRect().width)/(_zone.maxValue));
            },
            /**
            * _updateValueAndPosition, compute the value based on a position
            * @param {Number} newPosition
            */
            _updateValueAndPosition(newPosition){
              this.position = newPosition;
              var _zone = Polymer.dom(this).parentNode;
              this.value = Math.round((newPosition*(_zone.maxValue))/(_zone.getBoundingClientRect().width));
            },
            /**
            * _handleDown, Start the multi drag event
            * @param {event} e
            */
           _handleDown: function(e){
               e.preventDefault();
               this._startX = e.detail.x;
               this.listen(this, 'track', '_handleMove');
               this.listen(this, 'up', '_handleUp');
               this.visibility = "block";
            },
            /**
            * _handleMove, multi drag event
            * @param {event} e
            */
           _handleMove: function(e){
               e.preventDefault();
               var deltaX = e.detail.x - this._startX;
               var _parent = Polymer.dom(this).parentNode;
               var _children = Polymer.dom(_parent).querySelectorAll("slider-switch");
               for(var i=0;i<_children.length;i++){
                   if(_children[i].isSelected){
                       if(!_children[i].isDragging){
                           _children[i].isDragging = true;
                        }
                        var newPosition = _children[i].position + deltaX;
                        if(newPosition >= 0 && newPosition <= _parent.getBoundingClientRect().width){
                            if(!_parent.hasReachedMaxLimit && !_parent.hasReachedMinLimit){
                                _children[i]._updateValueAndPosition(newPosition);
                                _parent.checkLimitReached(newPosition);
                            }
                            if(_parent.hasReachedMaxLimit && (deltaX < 0)){
                                _children[i]._updateValueAndPosition(newPosition);
                                _parent.checkLimitReached(newPosition);
                            }
                            if(_parent.hasReachedMinLimit && (deltaX > 0)){
                                _children[i]._updateValueAndPosition(newPosition);
                                _parent.checkLimitReached(newPosition);
                            }

                        }
                   }
               }
               this._startX = e.detail.x;
            },
            /**
            * _handleUp, Finish multi drag event
            * @param {event} e
            */
           _handleUp: function(e){
               e.preventDefault();
               var _children = Polymer.dom(Polymer.dom(this).parentNode).querySelectorAll("slider-switch");
               for(var i=0;i<_children.length;i++){
                   if(_children[i].isDragging){
                       _children[i].isDragging = false;
                   }
               }
               this.visibility = "none";
               this.unlisten(this, 'track', '_handleMove');
               this.unlisten(this, 'up', '_handleUp');
            },
            /**
            * _displayText, show the current value
            * @param {Number} value
            */
            _displayText:function(value){
              if(value){
                this.visibility = "block";
              } else {
                this.visibility = "none";

              }
            }
       });
  </script>
</dom-module>
